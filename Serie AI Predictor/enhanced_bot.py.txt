#!/usr/bin/env python3
"""
SERIE AI - Simple Bot for Railway
This will run 24/7 on Railway
"""

import os
import sys
import logging
import threading
import time
from flask import Flask, Response
from telegram.ext import Application, CommandHandler

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Get bot token from Railway
BOT_TOKEN = os.environ.get("BOT_TOKEN")
PORT = int(os.environ.get("PORT", 8080))

if not BOT_TOKEN:
    logger.error("ERROR: BOT_TOKEN not set in Railway!")
    logger.info("Fix: Go to Railway â†’ Settings â†’ Variables â†’ Add BOT_TOKEN")
    sys.exit(1)

# ========== WEB SERVER FOR RAILWAY ==========
# Railway requires a web server. This is just for health checks.
flask_app = Flask(__name__)

@flask_app.route('/')
def home():
    return "ðŸ¤– Serie AI Bot is running!"

@flfask_app.route('/health')
def health():
    return "âœ… OK", 200

def run_web_server():
    flask_app.run(host='0.0.0.0', port=PORT, debug=False)

# ========== TELEGRAM BOT ==========
async def start_command(update, context):
    await update.message.reply_text(
        "ðŸ¤– *Serie AI Bot Online!*\n\n"
        "Commands:\n"
        "/predict [home] [away] - Match prediction\n"
        "/help - Show all commands\n\n"
        "Example: /predict Inter Milan",
        parse_mode='Markdown'
    )

async def predict_command(update, context):
    try:
        args = context.args
        if len(args) < 2:
            await update.message.reply_text("Usage: /predict HomeTeam AwayTeam")
            return
        
        home, away = args[0], args[1]
        
        # Simple prediction logic
        response = f"""
âš½ *Prediction: {home} vs {away}*

ðŸ“Š Simulated Results:
â€¢ Home Win: 48.5%
â€¢ Draw: 28.2%
â€¢ Away Win: 23.3%

ðŸŽ¯ Prediction: Home Win
ðŸ’° Confidence: Medium

_Note: This is demo data_"""
        
        await update.message.reply_text(response, parse_mode='Markdown')
    except Exception as e:
        await update.message.reply_text(f"Error: {str(e)}")

async def help_command(update, context):
    help_text = """
ðŸ¤– *SERIE AI BOT*

Commands:
/predict [home] [away] - Get match prediction
/help - Show this message

Example:
/predict Inter Milan
/predict Barcelona RealMadrid

Bot is running on Railway ðŸš€"""
    await update.message.reply_text(help_text, parse_mode='Markdown')

def run_bot():
    """Start the Telegram bot"""
    try:
        logger.info("Starting Telegram bot...")
        
        # Create bot
        app = Application.builder().token(BOT_TOKEN).build()
        
        # Add commands
        app.add_handler(CommandHandler("start", start_command))
        app.add_handler(CommandHandler("predict", predict_command))
        app.add_handler(CommandHandler("help", help_command))
        
        logger.info("Bot is ready!")
        logger.info("Go to Telegram and send /start to your bot")
        
        # Start bot
        app.run_polling()
        
    except Exception as e:
        logger.error(f"Bot error: {e}")
        sys.exit(1)

# ========== MAIN ==========
def main():
    print("=" * 50)
    print("ðŸš€ Starting Serie AI Bot")
    print("=" * 50)
    print(f"Bot token: {BOT_TOKEN[:10]}...")
    print(f"Web server port: {PORT}")
    print("=" * 50)
    
    # Start web server in background
    web_thread = threading.Thread(target=run_web_server, daemon=True)
    web_thread.start()
    
    # Wait for web server to start
    time.sleep(3)
    
    # Start bot (this runs forever)
    run_bot()

if __name__ == "__main__":
    main()